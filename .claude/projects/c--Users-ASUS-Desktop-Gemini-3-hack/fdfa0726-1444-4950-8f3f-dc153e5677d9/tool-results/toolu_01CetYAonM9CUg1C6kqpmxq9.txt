     1→'use client';
     2→
     3→import { useState, useEffect, useRef, useCallback, Suspense } from 'react';
     4→import { useSearchParams } from 'next/navigation';
     5→import Link from 'next/link';
     6→import DashboardNav from '@/components/DashboardNav';
     7→import DrillCard from '@/components/DrillCard';
     8→import { TabbedDrillAnimation } from '@/components/Skeleton3D';
     9→import PlayerSelectionModal from '@/components/PlayerSelectionModal';
    10→import { supabase, uploadVideo } from '@/lib/supabase';
    11→import {
    12→  drawSkeleton,
    13→  extractMetrics,
    14→  POSE_CONNECTIONS,
    15→  POSE_LANDMARKS
    16→} from '@/lib/pose-utils';
    17→import {
    18→  DRILLS,
    19→  FORM_RULES,
    20→  evaluateForm,
    21→  findViolationTimestamps,
    22→  type EvaluationResult
    23→} from '@/lib/rules-engine';
    24→import {
    25→  evaluateWithBands,
    26→  SCORING_LEGEND,
    27→  SKILL_LEVEL_DESCRIPTIONS,
    28→} from '@/lib/scoring-rules';
    29→import type { AnalysisResultJson, Issue, Drill, PoseLandmark, Session, PoseMetrics, PlayerTrackData } from '@/lib/types';
    30→
    31→// MediaPipe Types
    32→type PoseLandmarker = any;
    33→
    34→interface FrameAnalysis {
    35→  timestamp: number;
    36→  landmarks: PoseLandmark[] | null;
    37→  evaluation: EvaluationResult | null;
    38→  metrics: PoseMetrics | null;
    39→}
    40→
    41→interface DetectedIssue {
    42→  code: string;
    43→  title: string;
    44→  severity: 'low' | 'medium' | 'high';
    45→  description?: string;
    46→  timestamps: number[];
    47→  drill?: any;
    48→}
    49→
    50→function AnalyticsContent() {
    51→  const searchParams = useSearchParams();
    52→  const sessionId = searchParams.get('session');
    53→
    54→  // State
    55→  const [uploading, setUploading] = useState(false);
    56→  const [analyzing, setAnalyzing] = useState(false);
    57→  const [analyzeProgress, setAnalyzeProgress] = useState(0);
    58→  const [analysisId, setAnalysisId] = useState<string | null>(null);
    59→  const [result, setResult] = useState<AnalysisResultJson | null>(null);
    60→  const [error, setError] = useState<string | null>(null);
    61→  const [selectedIssue, setSelectedIssue] = useState<Issue | null>(null);
    62→  const [selectedDrill, setSelectedDrill] = useState<Drill | null>(null);
    63→
    64→  // Multi-pose and player selection state
    65→  const [showPlayerSelection, setShowPlayerSelection] = useState(false);
    66→  const [detectedTracks, setDetectedTracks] = useState<PlayerTrackData[]>([]);
    67→  const [selectedTrackIds, setSelectedTrackIds] = useState<number[]>([]);
    68→  const [detectedMatchFormat, setDetectedMatchFormat] = useState<'singles' | 'doubles' | null>(null);
    69→  const [matchFormat, setMatchFormat] = useState<'singles' | 'doubles'>('singles');
    70→  const [eventType, setEventType] = useState<string>('');
    71→
    72→  // Banded scoring state
    73→  const [skillLevel, setSkillLevel] = useState<'beginner' | 'intermediate' | 'advanced'>('intermediate');
    74→  const [currentBandedScore, setCurrentBandedScore] = useState<any>(null);
    75→
    76→  // Video playback state
    77→  const [videoUrl, setVideoUrl] = useState<string | null>(null);
    78→  const [videoFile, setVideoFile] = useState<File | null>(null);
    79→  const [poseData, setPoseData] = useState<Array<PoseLandmark[] | null>>([]);
    80→  const [frameAnalyses, setFrameAnalyses] = useState<FrameAnalysis[]>([]);
    81→  const [issues, setIssues] = useState<DetectedIssue[]>([]);
    82→  const [currentTime, setCurrentTime] = useState(0);
    83→  const [duration, setDuration] = useState(0);
    84→  const [isPlaying, setIsPlaying] = useState(false);
    85→  const [showSkeleton, setShowSkeleton] = useState(true);
    86→  const [fps, setFps] = useState(30);
    87→
    88→  // Pose detection
    89→  const [poseLandmarkerReady, setPoseLandmarkerReady] = useState(false);
    90→  const poseLandmarkerRef = useRef<PoseLandmarker | null>(null);
    91→
    92→  // Refs
    93→  const fileInputRef = useRef<HTMLInputElement>(null);
    94→  const videoRef = useRef<HTMLVideoElement>(null);
    95→  const canvasRef = useRef<HTMLCanvasElement>(null);
    96→  const processVideoRef = useRef<HTMLVideoElement | null>(null);
    97→  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
    98→  const animationRef = useRef<number | null>(null);
    99→
   100→  // Initialize MediaPipe Pose Landmarker
   101→  useEffect(() => {
   102→    initializePoseLandmarker();
   103→    return () => {
   104→      cleanup();
   105→    };
   106→  }, []);
   107→
   108→  // Load session if ID provided
   109→  useEffect(() => {
   110→    if (sessionId) {
   111→      loadSession(sessionId);
   112→    }
   113→  }, [sessionId]);
   114→
   115→  const initializePoseLandmarker = async () => {
   116→    try {
   117→      const vision = await import('@mediapipe/tasks-vision');
   118→      const { PoseLandmarker, FilesetResolver } = vision;
   119→
   120→      const filesetResolver = await FilesetResolver.forVisionTasks(
   121→        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
   122→      );
   123→
   124→      poseLandmarkerRef.current = await PoseLandmarker.createFromOptions(filesetResolver, {
   125→        baseOptions: {
   126→          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
   127→          delegate: 'GPU',
   128→        },
   129→        runningMode: 'VIDEO',
   130→        numPoses: 4, // Support up to 4 players for doubles
   131→        minPoseDetectionConfidence: 0.5,
   132→        minPosePresenceConfidence: 0.5,
   133→        minTrackingConfidence: 0.5,
   134→      });
   135→
   136→      setPoseLandmarkerReady(true);
   137→    } catch (error) {
   138→      console.error('Failed to load MediaPipe Pose:', error);
   139→      // Continue without pose detection - will use fallback
   140→    }
   141→  };
   142→
   143→  const cleanup = () => {
   144→    if (pollIntervalRef.current) {
   145→      clearInterval(pollIntervalRef.current);
   146→    }
   147→    if (animationRef.current) {
   148→      cancelAnimationFrame(animationRef.current);
   149→    }
   150→    if (poseLandmarkerRef.current) {
   151→      poseLandmarkerRef.current.close();
   152→    }
   153→  };
   154→
   155→  const loadSession = async (id: string) => {
   156→    try {
   157→      setAnalyzing(true);
   158→
   159→      // Try new sessions table first
   160→      const { data: sessionData, error: sessionError } = await supabase
   161→        .from('sessions')
   162→        .select('*')
   163→        .eq('id', id)
   164→        .single();
   165→
   166→      if (sessionError) {
   167→        // Try legacy table
   168→        const { data: legacyData, error: legacyError } = await supabase
   169→          .from('analysis_results')
   170→          .select('*')
   171→          .eq('id', id)
   172→          .single();
   173→
   174→        if (legacyError) throw legacyError;
   175→        if (legacyData?.result_json) {
   176→          setResult(legacyData.result_json);
   177→          if (legacyData.result_json.video_url) {
   178→            setVideoUrl(legacyData.result_json.video_url);
   179→          }
   180→        }
   181→      } else if (sessionData) {
   182→        // New session format
   183→        setVideoUrl(sessionData.video_url);
   184→
   185→        if (sessionData.pose_data) {
   186→          setPoseData(sessionData.pose_data);
   187→        }
   188→
   189→        // Fetch issues
   190→        const { data: issuesData } = await supabase
   191→          .from('issues')
   192→          .select('*')
   193→          .eq('session_id', id);
   194→
   195→        if (issuesData && issuesData.length > 0) {
   196→          setIssues(issuesData.map((issue: any) => ({
   197→            code: issue.code,
   198→            title: issue.title,
   199→            severity: issue.severity,
   200→            description: issue.description,
   201→            timestamps: issue.timestamps || [],
   202→            drill: issue.drill || DRILLS[issue.code?.toLowerCase().replace(/_/g, '-')],
   203→          })));
   204→        }
   205→
   206→        // Build result from session summary
   207→        const summary = sessionData.summary || {};
   208→        setResult({
   209→          top_issues: issuesData?.map((i: any) => ({
   210→            id: i.id,
   211→            title: i.title,
   212→            severity: i.severity,
   213→            description: i.description,
   214→            affected_metrics: [],
   215→          })) || [],
   216→          drills: issuesData?.map((i: any) => DRILLS[i.code?.toLowerCase().replace(/_/g, '-')]).filter(Boolean).map(d => ({
   217→            id: d.id,
   218→            name: d.name,
   219→            description: d.description,
   220→            duration_minutes: d.durationMinutes,
   221→            target_metrics: d.targetMetrics,
   222→            instructions: d.steps,
   223→          })) || [],
   224→          technique_summary: summary.feedback?.technique_summary || 'Analysis complete.',
   225→          strategy_summary: summary.feedback?.strategy_summary || '',
   226→          training_plan: [],
   227→        });
   228→      }
   229→    } catch (err) {
   230→      console.error('Error loading session:', err);
   231→      setError('Failed to load session');
   232→    } finally {
   233→      setAnalyzing(false);
   234→    }
   235→  };
   236→
   237→  // Process uploaded video with MediaPipe
   238→  const processVideoWithPose = async (
   239→    videoElement: HTMLVideoElement,
   240→    selectedTracks: number[] = [0]
   241→  ): Promise<FrameAnalysis[]> => {
   242→    if (!poseLandmarkerRef.current) {
   243→      console.warn('Pose landmarker not ready');
   244→      return [];
   245→    }
   246→
   247→    const analyses: FrameAnalysis[] = [];
   248→    const videoDuration = videoElement.duration;
   249→    const sampleRate = 10; // Process 10 frames per second
   250→    const totalFrames = Math.floor(videoDuration * sampleRate);
   251→
   252→    setAnalyzeProgress(10); // Start at 10% after track detection
   253→
   254→    for (let i = 0; i <= totalFrames; i++) {
   255→      const timestamp = i / sampleRate;
   256→      videoElement.currentTime = timestamp;
   257→
   258→      // Wait for video to seek
   259→      await new Promise<void>((resolve) => {
   260→        const onSeeked = () => {
   261→          videoElement.removeEventListener('seeked', onSeeked);
   262→          resolve();
   263→        };
   264→        videoElement.addEventListener('seeked', onSeeked);
   265→      });
   266→
   267→      // Give the video a moment to render the frame
   268→      await new Promise(resolve => setTimeout(resolve, 50));
   269→
   270→      try {
   271→        const results = poseLandmarkerRef.current.detectForVideo(
   272→          videoElement,
   273→          timestamp * 1000
   274→        );
   275→
   276→        let landmarks: PoseLandmark[] | null = null;
   277→        let evaluation: EvaluationResult | null = null;
   278→        let metrics: PoseMetrics | null = null;
   279→
   280→        if (results.landmarks && results.landmarks.length > 0) {
   281→          // Only use the selected player's landmarks
   282→          // For doubles, we could merge/average but for now take the first selected
   283→          const selectedPoseIdx = selectedTracks[0] < results.landmarks.length
   284→            ? selectedTracks[0]
   285→            : 0;
   286→
   287→          landmarks = results.landmarks[selectedPoseIdx].map((lm: any) => ({
   288→            x: lm.x,
   289→            y: lm.y,
   290→            z: lm.z,
   291→            visibility: lm.visibility ?? 1.0,
   292→          }));
   293→
   294→          if (landmarks) {
   295→            metrics = extractMetrics(landmarks);
   296→            // Use banded evaluation for more realistic scoring
   297→            const bandedResult = evaluateWithBands(landmarks, skillLevel);
   298→            evaluation = {
   299→              passed: bandedResult.overall_band === 'green' || bandedResult.overall_band === 'yellow',
   300→              score: bandedResult.overall_score,
   301→              failedRules: bandedResult.overall_band === 'red' ? bandedResult.feedback.map(f => ({
   302→                rule: { code: 'FORM', name: f, description: f, severity: 'medium' as const },
   303→                value: 0,
   304→                feedback: f,
   305→              })) : [],
   306→              passedRules: [],
   307→              highlightJoints: bandedResult.highlight_joints,
   308→              recommendedDrills: [],
   309→            };
   310→          }
   311→        }
   312→
   313→        analyses.push({
   314→          timestamp,
   315→          landmarks,
   316→          evaluation,
   317→          metrics,
   318→        });
   319→      } catch (err) {
   320→        console.warn('Error processing frame:', err);
   321→        analyses.push({
   322→          timestamp,
   323→          landmarks: null,
   324→          evaluation: null,
   325→          metrics: null,
   326→        });
   327→      }
   328→
   329→      // Update progress (10-95%)
   330→      setAnalyzeProgress(10 + Math.round((i / totalFrames) * 85));
   331→    }
   332→
   333→    return analyses;
   334→  };
   335→
   336→  // Detect issues from frame analyses
   337→  const detectIssuesFromAnalyses = (analyses: FrameAnalysis[]): DetectedIssue[] => {
   338→    const issueMap: Map<string, {
   339→      rule: any;
   340→      timestamps: number[];
   341→      count: number;
   342→    }> = new Map();
   343→
   344→    for (const frame of analyses) {
   345→      if (frame.evaluation && frame.evaluation.failedRules.length > 0) {
   346→        for (const failed of frame.evaluation.failedRules) {
   347→          const code = failed.rule.code;
   348→          if (!issueMap.has(code)) {
   349→            issueMap.set(code, {
   350→              rule: failed.rule,
   351→              timestamps: [],
   352→              count: 0,
   353→            });
   354→          }
   355→          const issue = issueMap.get(code)!;
   356→          issue.timestamps.push(frame.timestamp);
   357→          issue.count++;
   358→        }
   359→      }
   360→    }
   361→
   362→    // Convert to array and sort by count
   363→    const issues: DetectedIssue[] = Array.from(issueMap.entries())
   364→      .map(([code, data]) => ({
   365→        code,
   366→        title: data.rule.name,
   367→        severity: data.rule.severity,
   368→        description: data.rule.description,
   369→        timestamps: data.timestamps,
   370→        drill: DRILLS[data.rule.drillId],
   371→      }))
   372→      .sort((a, b) => b.timestamps.length - a.timestamps.length)
   373→      .slice(0, 5); // Top 5 issues
   374→
   375→    return issues;
   376→  };
   377→
   378→  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
   379→    const file = e.target.files?.[0];
   380→    if (!file) return;
   381→
   382→    if (!file.type.startsWith('video/')) {
   383→      setError('Please select a video file');
   384→      return;
   385→    }
   386→
   387→    if (file.size > 100 * 1024 * 1024) {
   388→      setError('File size must be less than 100MB');
   389→      return;
   390→    }
   391→
   392→    setError(null);
   393→    setVideoFile(file);
   394→    setResult(null);
   395→    setIssues([]);
   396→    setPoseData([]);
   397→    setFrameAnalyses([]);
   398→
   399→    // Create object URL for video preview
   400→    const objectUrl = URL.createObjectURL(file);
   401→    setVideoUrl(objectUrl);
   402→
   403→    // Start analysis
   404→    await analyzeVideo(file, objectUrl);
   405→  };
   406→
   407→  // Detect player tracks in the video
   408→  const detectPlayerTracks = async (videoElement: HTMLVideoElement): Promise<PlayerTrackData[]> => {
   409→    if (!poseLandmarkerRef.current) return [];
   410→
   411→    const tracks: Map<number, PlayerTrackData> = new Map();
   412→    const sampleFrames = 5; // Sample 5 frames to detect players
   413→    const duration = videoElement.duration;
   414→
   415→    for (let i = 0; i < sampleFrames; i++) {
   416→      const timestamp = (i / sampleFrames) * duration;
   417→      videoElement.currentTime = timestamp;
   418→
   419→      await new Promise<void>((resolve) => {
   420→        const onSeeked = () => {
   421→          videoElement.removeEventListener('seeked', onSeeked);
   422→          resolve();
   423→        };
   424→        videoElement.addEventListener('seeked', onSeeked);
   425→      });
   426→
   427→      await new Promise(resolve => setTimeout(resolve, 50));
   428→
   429→      try {
   430→        const results = poseLandmarkerRef.current.detectForVideo(
   431→          videoElement,
   432→          timestamp * 1000
   433→        );
   434→
   435→        if (results.landmarks && results.landmarks.length > 0) {
   436→          for (let poseIdx = 0; poseIdx < results.landmarks.length; poseIdx++) {
   437→            const landmarks = results.landmarks[poseIdx];
   438→            const bbox = calculateBoundingBox(landmarks);
   439→
   440→            if (!tracks.has(poseIdx)) {
   441→              tracks.set(poseIdx, {
   442→                track_id: poseIdx,
   443→                bbox_samples: [],
   444→                is_selected: false,
   445→                confidence_avg: 0,
   446→                frame_count: 0,
   447→                side: bbox.y < 0.5 ? 'far' : 'near',
   448→              });
   449→            }
   450→
   451→            const track = tracks.get(poseIdx)!;
   452→            track.bbox_samples.push({
   453→              frame: i,
   454→              x: bbox.x,
   455→              y: bbox.y,
   456→              w: bbox.w,
   457→              h: bbox.h,
   458→              confidence: landmarks[0].visibility || 0.5,
   459→            });
   460→            track.frame_count++;
   461→            track.confidence_avg =
   462→              (track.confidence_avg * (track.frame_count - 1) + (landmarks[0].visibility || 0.5)) /
   463→              track.frame_count;
   464→          }
   465→        }
   466→      } catch (err) {
   467→        console.warn('Error detecting poses in frame:', err);
   468→      }
   469→    }
   470→
   471→    return Array.from(tracks.values()).filter(t => t.frame_count >= 2);
   472→  };
   473→
   474→  // Calculate bounding box from landmarks
   475→  const calculateBoundingBox = (landmarks: any[]): { x: number; y: number; w: number; h: number } => {
   476→    let minX = 1, minY = 1, maxX = 0, maxY = 0;
   477→    for (const lm of landmarks) {
   478→      if (lm.visibility > 0.5) {
   479→        minX = Math.min(minX, lm.x);
   480→        minY = Math.min(minY, lm.y);
   481→        maxX = Math.max(maxX, lm.x);
   482→        maxY = Math.max(maxY, lm.y);
   483→      }
   484→    }
   485→    return {
   486→      x: minX,
   487→      y: minY,
   488→      w: maxX - minX,
   489→      h: maxY - minY,
   490→    };
   491→  };
   492→
   493→  // Handle player selection confirmation
   494→  const handlePlayerSelectionConfirm = (
   495→    selectedTracks: number[],
   496→    format: 'singles' | 'doubles',
   497→    event: string
   498→  ) => {
   499→    setSelectedTrackIds(selectedTracks);
   500→    setMatchFormat(format);
   501→    setEventType(event);
   502→    setShowPlayerSelection(false);
   503→
   504→    // Continue with analysis using selected tracks
   505→    if (processVideoRef.current && videoFile) {
   506→      continueAnalysisWithSelection(processVideoRef.current, selectedTracks);
   507→    }
   508→  };
   509→
   510→  // Continue analysis after player selection
   511→  const continueAnalysisWithSelection = async (
   512→    processVideo: HTMLVideoElement,
   513→    selectedTracks: number[]
   514→  ) => {
   515→    const analyses = await processVideoWithPose(processVideo, selectedTracks);
   516→    setFrameAnalyses(analyses);
   517→
   518→    const poseArray = analyses.map(a => a.landmarks);
   519→    setPoseData(poseArray);
   520→
   521→    const detectedIssues = detectIssuesFromAnalyses(analyses);
   522→    setIssues(detectedIssues);
   523→
   524→    const passedFrames = analyses.filter(a => a.evaluation?.passed).length;
   525→    const totalFrames = analyses.filter(a => a.evaluation).length;
   526→    const avgScore = totalFrames > 0
   527→      ? analyses.reduce((sum, a) => sum + (a.evaluation?.score || 0), 0) / totalFrames
   528→      : 0;
   529→
   530→    setResult({
   531→      top_issues: detectedIssues.map(issue => ({
   532→        id: issue.code,
   533→        title: issue.title,
   534→        severity: issue.severity,
   535→        description: issue.description || '',
   536→        affected_metrics: [],
   537→      })),
   538→      drills: detectedIssues.map(i => i.drill).filter(Boolean).map(d => ({
   539→        id: d.id,
   540→        name: d.name,
   541→        description: d.description,
   542→        duration_minutes: d.durationMinutes,
   543→        target_metrics: d.targetMetrics,
   544→        instructions: d.steps,
   545→      })),
   546→      technique_summary: `Analysis complete. Found ${detectedIssues.length} areas to improve. Overall form score: ${avgScore.toFixed(0)}%`,
   547→      strategy_summary: passedFrames > totalFrames * 0.7
   548→        ? 'Your form is generally good. Focus on the specific issues identified.'
   549→        : 'Work on maintaining consistent form throughout your movements.',
   550→      training_plan: [],
   551→    });
   552→
   553→    await saveAnalysisToDatabase(videoFile!, analyses, detectedIssues, avgScore);
   554→    setAnalyzing(false);
   555→    setAnalyzeProgress(100);
   556→  };
   557→
   558→  const analyzeVideo = async (file: File, videoObjectUrl: string) => {
   559→    setAnalyzing(true);
   560→    setAnalyzeProgress(0);
   561→
   562→    try {
   563→      // Create a hidden video element for processing
   564→      const processVideo = document.createElement('video');
   565→      processVideo.src = videoObjectUrl;
   566→      processVideo.muted = true;
   567→      processVideo.playsInline = true;
   568→      processVideoRef.current = processVideo;
   569→
   570→      // Wait for video to load metadata
   571→      await new Promise<void>((resolve, reject) => {
   572→        processVideo.onloadedmetadata = () => {
   573→          setDuration(processVideo.duration);
   574→          setFps(30); // Assume 30fps
   575→          resolve();
   576→        };
   577→        processVideo.onerror = () => reject(new Error('Failed to load video'));
   578→      });
   579→
   580→      // Wait for video to be fully loaded
   581→      await new Promise<void>((resolve) => {
   582→        if (processVideo.readyState >= 2) {
   583→          resolve();
   584→        } else {
   585→          processVideo.oncanplay = () => resolve();
   586→        }
   587→      });
   588→
   589→      // Detect player tracks first
   590→      setAnalyzeProgress(5);
   591→      const tracks = await detectPlayerTracks(processVideo);
   592→      setDetectedTracks(tracks);
   593→
   594→      // Auto-detect singles/doubles
   595→      const uniquePlayers = tracks.length;
   596→      const detectedFormat = uniquePlayers > 2 ? 'doubles' : 'singles';
   597→      setDetectedMatchFormat(detectedFormat);
   598→
   599→      // If multiple players detected, show selection modal
   600→      if (tracks.length > 1) {
   601→        setShowPlayerSelection(true);
   602→        return; // Wait for user selection before continuing
   603→      }
   604→
   605→      // If single player, auto-select and continue
   606→      if (tracks.length === 1) {
   607→        setSelectedTrackIds([tracks[0].track_id]);
   608→      }
   609→
   610→      // Process video with pose detection
   611→      let analyses: FrameAnalysis[] = [];
   612→
   613→      if (poseLandmarkerReady && poseLandmarkerRef.current) {
   614→        analyses = await processVideoWithPose(processVideo, selectedTrackIds.length > 0 ? selectedTrackIds : [0]);
   615→        setFrameAnalyses(analyses);
   616→
   617→        // Extract pose data array for rendering
   618→        const poseArray = analyses.map(a => a.landmarks);
   619→        setPoseData(poseArray);
   620→
   621→        // Detect issues
   622→        const detectedIssues = detectIssuesFromAnalyses(analyses);
   623→        setIssues(detectedIssues);
   624→
   625→        // Calculate overall stats
   626→        const passedFrames = analyses.filter(a => a.evaluation?.passed).length;
   627→        const totalFrames = analyses.filter(a => a.evaluation).length;
   628→        const avgScore = totalFrames > 0
   629→          ? analyses.reduce((sum, a) => sum + (a.evaluation?.score || 0), 0) / totalFrames
   630→          : 0;
   631→
   632→        // Build result
   633→        setResult({
   634→          top_issues: detectedIssues.map(issue => ({
   635→            id: issue.code,
   636→            title: issue.title,
   637→            severity: issue.severity,
   638→            description: issue.description || '',
   639→            affected_metrics: [],
   640→          })),
   641→          drills: detectedIssues.map(i => i.drill).filter(Boolean).map(d => ({
   642→            id: d.id,
   643→            name: d.name,
   644→            description: d.description,
   645→            duration_minutes: d.durationMinutes,
   646→            target_metrics: d.targetMetrics,
   647→            instructions: d.steps,
   648→          })),
   649→          technique_summary: `Analysis complete. Found ${detectedIssues.length} areas to improve. Overall form score: ${avgScore.toFixed(0)}%`,
   650→          strategy_summary: passedFrames > totalFrames * 0.7
   651→            ? 'Your form is generally good. Focus on the specific issues identified.'
   652→            : 'Work on maintaining consistent form throughout your movements.',
   653→          training_plan: [],
   654→        });
   655→
   656→        // Save to database
   657→        await saveAnalysisToDatabase(file, analyses, detectedIssues, avgScore);
   658→      } else {
   659→        // Fallback: Use backend API or show message
   660→        setError('Pose detection not available. Using demo mode.');
   661→
   662→        // Generate demo data
   663→        const demoIssues: DetectedIssue[] = [
   664→          {
   665→            code: 'ELBOW_ANGLE_OVERHEAD',
   666→            title: 'Elbow Extension (Overhead)',
   667→            severity: 'high',
   668→            description: 'Elbow should be nearly straight at contact point',
   669→            timestamps: [1.2, 3.5, 7.8],
   670→            drill: DRILLS['elbow-extension'],
   671→          },
   672→          {
   673→            code: 'KNEE_BEND',
   674→            title: 'Knee Bend',
   675→            severity: 'medium',
   676→            description: 'Bend knees more for power',
   677→            timestamps: [2.1, 5.3],
   678→            drill: DRILLS['lunge-practice'],
   679→          },
   680→        ];
   681→        setIssues(demoIssues);
   682→        setResult({
   683→          top_issues: demoIssues.map(i => ({
   684→            id: i.code,
   685→            title: i.title,
   686→            severity: i.severity,
   687→            description: i.description || '',
   688→            affected_metrics: [],
   689→          })),
   690→          drills: demoIssues.map(i => i.drill).filter(Boolean).map(d => ({
   691→            id: d!.id,
   692→            name: d!.name,
   693→            description: d!.description,
   694→            duration_minutes: d!.durationMinutes,
   695→            target_metrics: d!.targetMetrics,
   696→            instructions: d!.steps,
   697→          })),
   698→          technique_summary: 'Demo analysis complete. Enable camera permissions for real-time pose detection.',
   699→          strategy_summary: '',
   700→          training_plan: [],
   701→        });
   702→      }
   703→
   704→    } catch (err) {
   705→      console.error('Analysis error:', err);
   706→      setError('Failed to analyze video. Please try again.');
   707→    } finally {
   708→      setAnalyzing(false);
   709→      setAnalyzeProgress(100);
   710→    }
   711→  };
   712→
   713→  const saveAnalysisToDatabase = async (
   714→    file: File,
   715→    analyses: FrameAnalysis[],
   716→    detectedIssues: DetectedIssue[],
   717→    avgScore: number
   718→  ) => {
   719→    try {
   720→      const { data: { user } } = await supabase.auth.getUser();
   721→      if (!user) return;
   722→
   723→      // Upload video
   724→      const videoPath = await uploadVideo(file, user.id);
   725→
   726→      // Get video URL
   727→      let publicVideoUrl = '';
   728→      if (videoPath) {
   729→        const { data } = supabase.storage.from('videos').getPublicUrl(videoPath);
   730→        publicVideoUrl = data.publicUrl;
   731→      }
   732→
   733→      // Calculate stats
   734→      const passedFrames = analyses.filter(a => a.evaluation?.passed).length;
   735→      const totalFrames = analyses.filter(a => a.evaluation).length;
   736→
   737→      // Create session with enhanced fields
   738→      const { data: session, error: sessionError } = await supabase
   739→        .from('sessions')
   740→        .insert({
   741→          user_id: user.id,
   742→          type: 'analytics',
   743→          video_path: videoPath,
   744→          video_url: publicVideoUrl,
   745→          filename: file.name,
   746→          frame_count: analyses.length,
   747→          overall_score: Math.round(avgScore),
   748→          pose_data: analyses.map(a => a.landmarks),
   749→          // Enhanced v3 fields
   750→          status: 'ready',
   751→          match_format: matchFormat,
   752→          event_type: eventType || null,
   753→          selected_tracks: selectedTrackIds,
   754→          skill_level: skillLevel,
   755→          rules_version: 'v1',
   756→          summary: {
   757→            total_frames: totalFrames,
   758→            green_frames: passedFrames,
   759→            red_frames: totalFrames - passedFrames,
   760→            green_ratio: totalFrames > 0 ? passedFrames / totalFrames : 0,
   761→            average_score: avgScore,
   762→            duration_seconds: duration,
   763→          },
   764→        })
   765→        .select()
   766→        .single();
   767→
   768→      if (sessionError) {
   769→        console.error('Session save error:', sessionError);
   770→        return;
   771→      }
   772→
   773→      // Save issues
   774→      if (session && detectedIssues.length > 0) {
   775→        const issueInserts = detectedIssues.map(issue => ({
   776→          session_id: session.id,
   777→          code: issue.code,
   778→          title: issue.title,
   779→          severity: issue.severity,
   780→          description: issue.description,
   781→          timestamps: issue.timestamps,
   782→          drill: issue.drill,
   783→        }));
   784→
   785→        await supabase.from('issues').insert(issueInserts);
   786→      }
   787→
   788→    } catch (err) {
   789→      console.error('Error saving to database:', err);
   790→    }
   791→  };
   792→
   793→  // Video frame rendering with skeleton overlay
   794→  const renderFrame = useCallback(() => {
   795→    if (!videoRef.current || !canvasRef.current) return;
   796→
   797→    const video = videoRef.current;
   798→    const canvas = canvasRef.current;
   799→    const ctx = canvas.getContext('2d');
   800→    if (!ctx) return;
   801→
   802→    // Resize canvas to match video
   803→    if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
   804→      canvas.width = video.videoWidth || 640;
   805→      canvas.height = video.videoHeight || 480;
   806→    }
   807→
   808→    // Clear canvas
   809→    ctx.clearRect(0, 0, canvas.width, canvas.height);
   810→
   811→    if (!showSkeleton) return;
   812→
   813→    // Find the closest frame analysis
   814→    let closestFrame: FrameAnalysis | null = null;
   815→    let minDiff = Infinity;
   816→
   817→    for (const frame of frameAnalyses) {
   818→      const diff = Math.abs(frame.timestamp - video.currentTime);
   819→      if (diff < minDiff) {
   820→        minDiff = diff;
   821→        closestFrame = frame;
   822→      }
   823→    }
   824→
   825→    // Also check raw poseData array (for loaded sessions)
   826→    if (!closestFrame && poseData.length > 0) {
   827→      const frameIndex = Math.floor(video.currentTime * 10); // Assuming 10fps sample rate
   828→      const landmarks = poseData[Math.min(frameIndex, poseData.length - 1)];
   829→      if (landmarks) {
   830→        closestFrame = {
   831→          timestamp: video.currentTime,
   832→          landmarks,
   833→          evaluation: evaluateForm(landmarks, 'general'),
   834→          metrics: extractMetrics(landmarks),
   835→        };
   836→      }
   837→    }
   838→
   839→    if (closestFrame?.landmarks) {
   840→      // Use banded scoring for more nuanced feedback
   841→      const bandedResult = evaluateWithBands(closestFrame.landmarks, skillLevel);
   842→      setCurrentBandedScore(bandedResult);
   843→
   844→      // Determine color based on band
   845→      const isGreen = bandedResult.overall_band === 'green';
   846→      const isYellow = bandedResult.overall_band === 'yellow';
   847→
   848→      // Draw with appropriate color
   849→      const color = isGreen ? '#22c55e' : isYellow ? '#eab308' : '#ef4444';
   850→
   851→      // Custom draw with banded colors
   852→      ctx.strokeStyle = color;
   853→      ctx.lineWidth = 3;
   854→      ctx.fillStyle = color;
   855→
   856→      // Draw skeleton connections
   857→      for (const [startIdx, endIdx] of POSE_CONNECTIONS) {
   858→        const start = closestFrame.landmarks[startIdx];
   859→        const end = closestFrame.landmarks[endIdx];
   860→        if (start && end && start.visibility > 0.5 && end.visibility > 0.5) {
   861→          ctx.beginPath();
   862→          ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
   863→          ctx.lineTo(end.x * canvas.width, end.y * canvas.height);
   864→          ctx.stroke();
   865→        }
   866→      }
   867→
   868→      // Draw joints
   869→      for (const landmark of closestFrame.landmarks) {
   870→        if (landmark.visibility > 0.5) {
   871→          ctx.beginPath();
   872→          ctx.arc(
   873→            landmark.x * canvas.width,
   874→            landmark.y * canvas.height,
   875→            5,
   876→            0,
   877→            2 * Math.PI
   878→          );
   879→          ctx.fill();
   880→        }
   881→      }
   882→    }
   883→
   884→    if (!video.paused) {
   885→      animationRef.current = requestAnimationFrame(renderFrame);
   886→    }
   887→  }, [frameAnalyses, poseData, showSkeleton]);
   888→
   889→  // Trigger skeleton render when poseData is loaded
   890→  useEffect(() => {
   891→    if (poseData.length > 0 && videoRef.current) {
   892→      // Wait for video to be ready then render
   893→      const tryRender = () => {
   894→        if (videoRef.current && videoRef.current.readyState >= 2) {
   895→          renderFrame();
   896→        } else {
   897→          setTimeout(tryRender, 100);
   898→        }
   899→      };
   900→      tryRender();
   901→    }
   902→  }, [poseData, renderFrame]);
   903→
   904→  // Handle video time updates
   905→  const handleTimeUpdate = useCallback(() => {
   906→    if (videoRef.current) {
   907→      setCurrentTime(videoRef.current.currentTime);
   908→      renderFrame();
   909→    }
   910→  }, [renderFrame]);
   911→
   912→  // Handle video play/pause
   913→  const togglePlayPause = useCallback(() => {
   914→    if (videoRef.current) {
   915→      if (videoRef.current.paused) {
   916→        videoRef.current.play();
   917→        setIsPlaying(true);
   918→        animationRef.current = requestAnimationFrame(renderFrame);
   919→      } else {
   920→        videoRef.current.pause();
   921→        setIsPlaying(false);
   922→        if (animationRef.current) {
   923→          cancelAnimationFrame(animationRef.current);
   924→        }
   925→      }
   926→    }
   927→  }, [renderFrame]);
   928→
   929→  // Jump to timestamp
   930→  const jumpToTimestamp = useCallback((timestamp: number) => {
   931→    if (videoRef.current) {
   932→      videoRef.current.currentTime = timestamp;
   933→      videoRef.current.pause();
   934→      setIsPlaying(false);
   935→      setCurrentTime(timestamp);
   936→      // Force render frame at new position
   937→      setTimeout(renderFrame, 50);
   938→    }
   939→  }, [renderFrame]);
   940→
   941→  // Find next mistake
   942→  const goToNextMistake = useCallback(() => {
   943→    const allTimestamps = issues
   944→      .flatMap((i) => i.timestamps || [])
   945→      .sort((a, b) => a - b);
   946→
   947→    const nextTimestamp = allTimestamps.find((t) => t > currentTime + 0.5);
   948→    if (nextTimestamp !== undefined) {
   949→      jumpToTimestamp(nextTimestamp);
   950→    } else if (allTimestamps.length > 0) {
   951→      // Wrap around to first
   952→      jumpToTimestamp(allTimestamps[0]);
   953→    }
   954→  }, [issues, currentTime, jumpToTimestamp]);
   955→
   956→  // Handle video metadata loaded
   957→  const handleLoadedMetadata = useCallback(() => {
   958→    if (videoRef.current) {
   959→      setDuration(videoRef.current.duration);
   960→      // Initial render
   961→      setTimeout(renderFrame, 100);
   962→    }
   963→  }, [renderFrame]);
   964→
   965→  const getSeverityColor = (severity: string) => {
   966→    switch (severity) {
   967→      case 'high':
   968→        return 'bg-red-50 border-red-200 text-red-800';
   969→      case 'medium':
   970→        return 'bg-yellow-50 border-yellow-200 text-yellow-800';
   971→      case 'low':
   972→        return 'bg-green-50 border-green-200 text-green-800';
   973→      default:
   974→        return 'bg-gray-50 border-gray-200 text-gray-800';
   975→    }
   976→  };
   977→
   978→  const formatTime = (seconds: number) => {
   979→    const mins = Math.floor(seconds / 60);
   980→    const secs = Math.floor(seconds % 60);
   981→    return `${mins}:${secs.toString().padStart(2, '0')}`;
   982→  };
   983→
   984→  // Get current frame info for display
   985→  const getCurrentFrameInfo = () => {
   986→    if (frameAnalyses.length === 0) return null;
   987→
   988→    let closestFrame: FrameAnalysis | null = null;
   989→    let minDiff = Infinity;
   990→
   991→    for (const frame of frameAnalyses) {
   992→      const diff = Math.abs(frame.timestamp - currentTime);
   993→      if (diff < minDiff) {
   994→        minDiff = diff;
   995→        closestFrame = frame;
   996→      }
   997→    }
   998→
   999→    return closestFrame;
  1000→  };
  1001→
  1002→  const currentFrameInfo = getCurrentFrameInfo();
  1003→
  1004→  return (
  1005→    <div className="min-h-screen bg-gray-50">
  1006→      <DashboardNav />
  1007→
  1008→      <main className="ml-64 p-8">
  1009→        <div className="max-w-7xl mx-auto">
  1010→          {/* Header */}
  1011→          <div className="mb-8">
  1012→            <h1 className="text-3xl font-bold text-gray-900">Video Analytics</h1>
  1013→            <p className="text-gray-600 mt-1">
  1014→              {sessionId ? 'Review your analysis results' : 'Upload a video for AI-powered technique analysis'}
  1015→            </p>
  1016→          </div>
  1017→
  1018→          {/* Upload Section */}
  1019→          {!result && !videoUrl && (
  1020→            <div className="bg-white rounded-xl p-8 shadow-sm mb-8">
  1021→              <div
  1022→                className={`border-2 border-dashed rounded-xl p-12 text-center transition ${
  1023→                  uploading || analyzing
  1024→                    ? 'border-primary-300 bg-primary-50'
  1025→                    : 'border-gray-300 hover:border-primary-400'
  1026→                }`}
  1027→              >
  1028→                {uploading ? (
  1029→                  <div className="space-y-4">
  1030→                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-500 mx-auto"></div>
  1031→                    <p className="text-gray-600">Uploading video...</p>
  1032→                  </div>
  1033→                ) : analyzing ? (
  1034→                  <div className="space-y-4">
  1035→                    <div className="w-16 h-16 bg-primary-100 rounded-full flex items-center justify-center mx-auto">
  1036→                      <svg className="w-8 h-8 text-primary-500 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  1037→                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
  1038→                      </svg>
  1039→                    </div>
  1040→                    <p className="text-gray-900 font-medium">Analyzing your technique...</p>
  1041→                    <p className="text-gray-500 text-sm">Processing pose detection frame by frame</p>
  1042→                    <div className="w-64 mx-auto bg-gray-200 rounded-full h-2">
  1043→                      <div
  1044→                        className="bg-primary-500 h-2 rounded-full transition-all duration-300"
  1045→                        style={{ width: `${analyzeProgress}%` }}
  1046→                      ></div>
  1047→                    </div>
  1048→                    <p className="text-sm text-gray-500">{analyzeProgress}% complete</p>
  1049→                  </div>
  1050→                ) : (
  1051→                  <>
  1052→                    <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
  1053→                      <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  1054→                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
  1055→                      </svg>
  1056→                    </div>
  1057→                    <h3 className="text-lg font-medium text-gray-900 mb-2">Upload your badminton video</h3>
  1058→                    <p className="text-gray-500 mb-4">MP4, MOV, or WebM up to 100MB</p>
  1059→                    {poseLandmarkerReady && (
  1060→                      <p className="text-sm text-green-600 mb-4">Pose detection ready</p>
  1061→                    )}
  1062→                    <input ref={fileInputRef} type="file" accept="video/*" onChange={handleFileSelect} className="hidden" />
  1063→                    <button onClick={() => fileInputRef.current?.click()} className="px-6 py-3 bg-primary-500 text-white rounded-lg font-medium hover:bg-primary-600 transition">
  1064→                      Select Video
  1065→                    </button>
  1066→                  </>
  1067→                )}
  1068→              </div>
  1069→
  1070→              {error && (
  1071→                <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">{error}</div>
  1072→              )}
  1073→            </div>
  1074→          )}
  1075→
  1076→          {/* Video Player with Overlay */}
  1077→          {videoUrl && (
  1078→            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
  1079→              <div className="lg:col-span-2">
  1080→                <div className="bg-gray-900 rounded-xl overflow-hidden">
  1081→                  <div className="relative aspect-video">
  1082→                    <video
  1083→                      ref={videoRef}
  1084→                      src={videoUrl}
  1085→                      className="absolute inset-0 w-full h-full object-contain"
  1086→                      onTimeUpdate={handleTimeUpdate}
  1087→                      onLoadedMetadata={handleLoadedMetadata}
  1088→                      onEnded={() => setIsPlaying(false)}
  1089→                      playsInline
  1090→                    />
  1091→                    <canvas
  1092→                      ref={canvasRef}
  1093→                      className={`absolute inset-0 w-full h-full object-contain pointer-events-none ${
  1094→                        showSkeleton ? '' : 'hidden'
  1095→                      }`}
  1096→                    />
  1097→
  1098→                    {/* Status indicator with banded scoring */}
  1099→                    {currentBandedScore && (
  1100→                      <div className={`absolute top-4 left-4 px-3 py-1.5 rounded-full text-sm font-medium ${
  1101→                        currentBandedScore.overall_band === 'green' ? 'bg-green-500 text-white' :
  1102→                        currentBandedScore.overall_band === 'yellow' ? 'bg-yellow-500 text-white' :
  1103→                        currentBandedScore.overall_band === 'red' ? 'bg-red-500 text-white' :
  1104→                        'bg-gray-500 text-white'
  1105→                      }`}>
  1106→                        {SCORING_LEGEND[currentBandedScore.overall_band as keyof typeof SCORING_LEGEND]?.label || 'Unknown'}
  1107→                        <span className="ml-2 opacity-75">
  1108→                          {Math.round(currentBandedScore.overall_score)}%
  1109→                        </span>
  1110→                      </div>
  1111→                    )}
  1112→
  1113→                    {/* Time display */}
  1114→                    <div className="absolute top-4 right-4 bg-black/50 text-white px-3 py-1 rounded-full text-sm">
  1115→                      {formatTime(currentTime)} / {formatTime(duration)}
  1116→                    </div>
  1117→
  1118→                    {/* Current metrics display */}
  1119→                    {currentFrameInfo?.metrics && (
  1120→                      <div className="absolute bottom-16 left-4 bg-black/70 text-white p-3 rounded-lg text-xs">
  1121→                        <p>Elbow: {currentFrameInfo.metrics.elbow_angle.toFixed(0)}deg</p>
  1122→                        <p>Knee: {currentFrameInfo.metrics.knee_angle.toFixed(0)}deg</p>
  1123→                        <p>Stance: {(currentFrameInfo.metrics.stance_width_norm * 100).toFixed(0)}%</p>
  1124→                      </div>
  1125→                    )}
  1126→                  </div>
  1127→
  1128→                  {/* Controls */}
  1129→                  <div className="p-4 flex items-center justify-between">
  1130→                    <div className="flex items-center gap-2">
  1131→                      <button
  1132→                        onClick={togglePlayPause}
  1133→                        className="p-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 transition"
  1134→                      >
  1135→                        {isPlaying ? (
  1136→                          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  1137→                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  1138→                          </svg>
  1139→                        ) : (
  1140→                          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
  1141→                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
  1142→                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
  1143→                          </svg>
  1144→                        )}
  1145→                      </button>
  1146→
  1147→                      <button
  1148→                        onClick={goToNextMistake}
  1149→                        disabled={issues.length === 0}
  1150→                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition text-sm font-medium disabled:opacity-50"
  1151→                      >
  1152→                        Next Mistake
  1153→                      </button>
  1154→                    </div>
  1155→
  1156→                    <div className="flex items-center gap-4">
  1157→                      {/* Skill level selector */}
  1158→                      <select
  1159→                        value={skillLevel}
  1160→                        onChange={(e) => setSkillLevel(e.target.value as any)}
  1161→                        className="text-sm bg-gray-800 text-white border-gray-700 rounded-lg px-2 py-1"
  1162→                        title="Adjust scoring sensitivity"
  1163→                      >
  1164→                        <option value="beginner">Beginner</option>
  1165→                        <option value="intermediate">Intermediate</option>
  1166→                        <option value="advanced">Advanced</option>
  1167→                      </select>
  1168→
  1169→                      <label className="flex items-center gap-2 text-white text-sm">
  1170→                        <input
  1171→                          type="checkbox"
  1172→                          checked={showSkeleton}
  1173→                          onChange={(e) => {
  1174→                            setShowSkeleton(e.target.checked);
  1175→                            if (e.target.checked) {
  1176→                              setTimeout(renderFrame, 50);
  1177→                            }
  1178→                          }}
  1179→                          className="rounded"
  1180→                        />
  1181→                        Show Skeleton
  1182→                      </label>
  1183→                    </div>
  1184→                  </div>
  1185→
  1186→                  {/* Timeline scrubber */}
  1187→                  <div className="px-4 pb-4">
  1188→                    <input
  1189→                      type="range"
  1190→                      min={0}
  1191→                      max={duration || 100}
  1192→                      step={0.1}
  1193→                      value={currentTime}
  1194→                      onChange={(e) => {
  1195→                        const time = parseFloat(e.target.value);
  1196→                        if (videoRef.current) {
  1197→                          videoRef.current.currentTime = time;
  1198→                          setCurrentTime(time);
  1199→                          // Force render skeleton at new position
  1200→                          setTimeout(renderFrame, 50);
  1201→                        }
  1202→                      }}
  1203→                      className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
  1204→                    />
  1205→                  </div>
  1206→                </div>
  1207→
  1208→                {/* Analysis Summary */}
  1209→                {result && (
  1210→                  <div className="mt-6 bg-white rounded-xl p-6 shadow-sm">
  1211→                    <h3 className="font-semibold text-gray-900 mb-3">Analysis Summary</h3>
  1212→                    <p className="text-gray-600">{result.technique_summary}</p>
  1213→                    {result.strategy_summary && (
  1214→                      <p className="text-gray-500 mt-2 text-sm">{result.strategy_summary}</p>
  1215→                    )}
  1216→                  </div>
  1217→                )}
  1218→              </div>
  1219→
  1220→              {/* Issues Panel */}
  1221→              <div className="space-y-4">
  1222→                <h3 className="font-semibold text-gray-900">Detected Issues</h3>
  1223→                {analyzing ? (
  1224→                  <div className="bg-white rounded-xl p-6 shadow-sm animate-pulse">
  1225→                    <div className="h-4 bg-gray-200 rounded w-3/4 mb-3"></div>
  1226→                    <div className="h-4 bg-gray-200 rounded w-1/2"></div>
  1227→                  </div>
  1228→                ) : issues.length > 0 ? (
  1229→                  <div className="space-y-4 max-h-[600px] overflow-y-auto">
  1230→                    {issues.map((issue, index) => (
  1231→                      <DrillCard
  1232→                        key={index}
  1233→                        issue={issue}
  1234→                        onTimestampClick={jumpToTimestamp}
  1235→                        currentTime={currentTime}
  1236→                      />
  1237→                    ))}
  1238→                  </div>
  1239→                ) : (
  1240→                  <div className="bg-green-50 border border-green-200 rounded-xl p-4 text-green-800">
  1241→                    <p className="font-medium">Great form!</p>
  1242→                    <p className="text-sm">No major issues detected in this video.</p>
  1243→                  </div>
  1244→                )}
  1245→
  1246→                {/* Reset button */}
  1247→                {videoUrl && !analyzing && (
  1248→                  <button
  1249→                    onClick={() => {
  1250→                      setResult(null);
  1251→                      setVideoUrl(null);
  1252→                      setVideoFile(null);
  1253→                      setIssues([]);
  1254→                      setPoseData([]);
  1255→                      setFrameAnalyses([]);
  1256→                      setCurrentTime(0);
  1257→                      setDuration(0);
  1258→                    }}
  1259→                    className="w-full py-3 border border-gray-300 rounded-lg text-gray-700 font-medium hover:bg-gray-50 transition"
  1260→                  >
  1261→                    Analyze Another Video
  1262→                  </button>
  1263→                )}
  1264→              </div>
  1265→            </div>
  1266→          )}
  1267→
  1268→          {/* Results Section (legacy format without video) */}
  1269→          {result && !videoUrl && (
  1270→            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
  1271→              {/* Left Column - Issues */}
  1272→              <div className="space-y-6">
  1273→                <div className="bg-white rounded-xl p-6 shadow-sm">
  1274→                  <h2 className="text-lg font-semibold text-gray-900 mb-4">Areas to Improve</h2>
  1275→                  <div className="space-y-3">
  1276→                    {result.top_issues.map((issue) => (
  1277→                      <button
  1278→                        key={issue.id}
  1279→                        onClick={() => setSelectedIssue(issue)}
  1280→                        className={`w-full text-left p-4 rounded-lg border transition ${
  1281→                          selectedIssue?.id === issue.id ? 'ring-2 ring-primary-500' : ''
  1282→                        } ${getSeverityColor(issue.severity)}`}
  1283→                      >
  1284→                        <div className="flex items-center justify-between mb-1">
  1285→                          <span className="font-medium">{issue.title}</span>
  1286→                          <span className="text-xs uppercase font-semibold">{issue.severity}</span>
  1287→                        </div>
  1288→                        <p className="text-sm opacity-80">{issue.description}</p>
  1289→                      </button>
  1290→                    ))}
  1291→                  </div>
  1292→                </div>
  1293→
  1294→                <div className="bg-white rounded-xl p-6 shadow-sm">
  1295→                  <h2 className="text-lg font-semibold text-gray-900 mb-3">Technique Summary</h2>
  1296→                  <p className="text-gray-600">{result.technique_summary}</p>
  1297→                </div>
  1298→              </div>
  1299→
  1300→              {/* Right Column - Drills */}
  1301→              <div className="space-y-6">
  1302→                <div className="bg-white rounded-xl p-6 shadow-sm">
  1303→                  <h2 className="text-lg font-semibold text-gray-900 mb-4">Recommended Drills</h2>
  1304→                  <div className="space-y-3">
  1305→                    {result.drills.map((drill) => (
  1306→                      <button
  1307→                        key={drill.id}
  1308→                        onClick={() => setSelectedDrill(drill)}
  1309→                        className={`w-full text-left p-4 rounded-lg border border-gray-200 hover:border-primary-300 transition ${
  1310→                          selectedDrill?.id === drill.id ? 'ring-2 ring-primary-500 border-primary-300' : ''
  1311→                        }`}
  1312→                      >
  1313→                        <div className="flex items-center justify-between mb-1">
  1314→                          <span className="font-medium text-gray-900">{drill.name}</span>
  1315→                          <span className="text-sm text-gray-500">{drill.duration_minutes} min</span>
  1316→                        </div>
  1317→                        <p className="text-sm text-gray-600">{drill.description}</p>
  1318→                      </button>
  1319→                    ))}
  1320→                  </div>
  1321→                </div>
  1322→
  1323→                {selectedDrill && (
  1324→                  <div className="bg-gradient-to-br from-primary-50 to-primary-100 rounded-xl p-6">
  1325→                    <div className="flex items-center justify-between mb-4">
  1326→                      <h3 className="text-lg font-semibold text-gray-900">{selectedDrill.name}</h3>
  1327→                      <Link
  1328→                        href={`/practice?drill=${selectedDrill.id}`}
  1329→                        className="px-4 py-2 bg-primary-500 text-white rounded-lg text-sm font-medium hover:bg-primary-600 transition"
  1330→                      >
  1331→                        Let&apos;s Practice
  1332→                      </Link>
  1333→                    </div>
  1334→                    <div className="space-y-3">
  1335→                      <p className="text-gray-700">{selectedDrill.description}</p>
  1336→                      <div>
  1337→                        <p className="font-medium text-gray-900 mb-2">Instructions:</p>
  1338→                        <ol className="list-decimal list-inside space-y-1 text-gray-700">
  1339→                          {selectedDrill.instructions.map((instruction, i) => (
  1340→                            <li key={i}>{instruction}</li>
  1341→                          ))}
  1342→                        </ol>
  1343→                      </div>
  1344→                    </div>
  1345→                  </div>
  1346→                )}
  1347→
  1348→                <button
  1349→                  onClick={() => {
  1350→                    setResult(null);
  1351→                    setSelectedIssue(null);
  1352→                    setSelectedDrill(null);
  1353→                    setVideoUrl(null);
  1354→                    setPoseData([]);
  1355→                    setIssues([]);
  1356→                  }}
  1357→                  className="w-full py-3 border border-gray-300 rounded-lg text-gray-700 font-medium hover:bg-gray-50 transition"
  1358→                >
  1359→                  Analyze Another Video
  1360→                </button>
  1361→              </div>
  1362→            </div>
  1363→          )}
  1364→        </div>
  1365→      </main>
  1366→
  1367→      {/* Player Selection Modal */}
  1368→      <PlayerSelectionModal
  1369→        isOpen={showPlayerSelection}
  1370→        onClose={() => {
  1371→          setShowPlayerSelection(false);
  1372→          // Reset if user cancels
  1373→          setAnalyzing(false);
  1374→          setVideoUrl(null);
  1375→          setVideoFile(null);
  1376→        }}
  1377→        onConfirm={handlePlayerSelectionConfirm}
  1378→        tracks={detectedTracks}
  1379→        detectedFormat={detectedMatchFormat}
  1380→      />
  1381→    </div>
  1382→  );
  1383→}
  1384→
  1385→function AnalyticsLoading() {
  1386→  return (
  1387→    <div className="min-h-screen bg-gray-50">
  1388→      <DashboardNav />
  1389→      <main className="ml-64 p-8">
  1390→        <div className="max-w-7xl mx-auto">
  1391→          <div className="animate-pulse">
  1392→            <div className="h-8 bg-gray-200 rounded w-48 mb-4"></div>
  1393→            <div className="h-4 bg-gray-200 rounded w-96 mb-8"></div>
  1394→            <div className="bg-gray-200 rounded-xl h-96"></div>
  1395→          </div>
  1396→        </div>
  1397→      </main>
  1398→    </div>
  1399→  );
  1400→}
  1401→
  1402→export default function AnalyticsPage() {
  1403→  return (
  1404→    <Suspense fallback={<AnalyticsLoading />}>
  1405→      <AnalyticsContent />
  1406→    </Suspense>
  1407→  );
  1408→}
  1409→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
