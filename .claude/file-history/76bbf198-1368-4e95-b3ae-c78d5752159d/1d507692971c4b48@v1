import { createClient, SupabaseClient } from '@supabase/supabase-js';
import * as tus from 'tus-js-client';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

// Constants for upload handling
const RESUMABLE_THRESHOLD = 6 * 1024 * 1024; // 6MB - use TUS for files larger than this
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB max file size
const STORAGE_BUCKET = 'videos';
const PRACTICE_RECORDINGS_BUCKET = 'practice-recordings';

// Client-side Supabase client (lazy initialization)
let _supabase: SupabaseClient | null = null;

export const supabase = (() => {
  if (!_supabase && supabaseUrl && supabaseAnonKey) {
    _supabase = createClient(supabaseUrl, supabaseAnonKey);
  }
  // Return a mock client if env vars not available (for SSR)
  if (!_supabase) {
    return createClient(
      supabaseUrl || 'https://placeholder.supabase.co',
      supabaseAnonKey || 'placeholder-key'
    );
  }
  return _supabase;
})();

// Server-side Supabase client (for API routes)
export function createServerClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL || supabaseUrl;
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || supabaseAnonKey;

  if (!url || !key) {
    throw new Error('Supabase environment variables not configured');
  }

  return createClient(url, key, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}

// Helper to get user from request
export async function getUserFromRequest(request: Request) {
  const authHeader = request.headers.get('authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }

  const token = authHeader.split(' ')[1];
  const serverClient = createServerClient();

  const { data: { user }, error } = await serverClient.auth.getUser(token);

  if (error || !user) {
    return null;
  }

  return user;
}

// Sanitize filename to remove non-ASCII characters for Supabase storage
function sanitizeFileName(fileName: string): string {
  // Get file extension
  const lastDot = fileName.lastIndexOf('.');
  const ext = lastDot > 0 ? fileName.slice(lastDot) : '';
  const baseName = lastDot > 0 ? fileName.slice(0, lastDot) : fileName;

  // Replace non-ASCII characters with empty string, keep alphanumeric, dash, underscore
  const sanitized = baseName
    .replace(/[^\x00-\x7F]/g, '') // Remove non-ASCII
    .replace(/[^a-zA-Z0-9_-]/g, '_') // Replace special chars with underscore
    .replace(/_+/g, '_') // Collapse multiple underscores
    .replace(/^_|_$/g, '') // Trim underscores from start/end
    || 'video'; // Default name if nothing remains

  return sanitized + ext;
}

// Upload progress callback type
export type UploadProgressCallback = (progress: number) => void;

// Upload result type
export interface UploadResult {
  path: string;
  bucket: string;
  publicUrl: string;
}

// Storage helpers

/**
 * Upload video with automatic selection of standard or TUS resumable upload
 * based on file size. Files > 6MB use TUS protocol for reliability.
 *
 * @param file - The video file to upload
 * @param userId - The user ID for path organization
 * @param onProgress - Optional progress callback (0-100)
 * @returns UploadResult with path, bucket, and publicUrl
 * @throws Error if upload fails
 */
export async function uploadVideo(
  file: File,
  userId: string,
  onProgress?: UploadProgressCallback
): Promise<string | null> {
  // Validate file size
  if (file.size > MAX_FILE_SIZE) {
    console.error('Upload error: File size exceeds 100MB limit');
    throw new Error('File size exceeds 100MB limit. Please compress your video before uploading.');
  }

  // Validate file type
  if (!file.type.startsWith('video/')) {
    throw new Error('Invalid file type. Please upload a video file.');
  }

  const sanitizedName = sanitizeFileName(file.name);
  const fileName = `${userId}/${Date.now()}-${sanitizedName}`;

  // Use TUS resumable upload for large files
  if (file.size > RESUMABLE_THRESHOLD) {
    console.log(`Using TUS resumable upload for ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
    return await uploadVideoResumable(file, fileName, onProgress);
  }

  // Use standard upload for small files
  console.log(`Using standard upload for ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
  return await uploadVideoStandard(file, fileName, onProgress);
}

/**
 * Standard upload for files < 6MB
 */
async function uploadVideoStandard(
  file: File,
  fileName: string,
  onProgress?: UploadProgressCallback
): Promise<string | null> {
  // Report initial progress
  onProgress?.(10);

  const { data, error } = await supabase.storage
    .from(STORAGE_BUCKET)
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: false
    });

  if (error) {
    console.error('Upload error:', error);
    if (error.message?.includes('exceeded the maximum allowed size')) {
      throw new Error('File size exceeds storage limit. Please compress your video before uploading.');
    }
    if (error.message?.includes('Bucket not found')) {
      throw new Error('Storage not configured. Please contact support.');
    }
    throw new Error(`Failed to upload video: ${error.message}`);
  }

  onProgress?.(100);
  return data.path;
}

/**
 * TUS resumable upload for files >= 6MB
 * Uses tus-js-client for reliable large file uploads with resume capability
 */
async function uploadVideoResumable(
  file: File,
  fileName: string,
  onProgress?: UploadProgressCallback
): Promise<string | null> {
  return new Promise(async (resolve, reject) => {
    try {
      // Get the current session for auth token
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token) {
        throw new Error('Not authenticated. Please log in again.');
      }

      const upload = new tus.Upload(file, {
        endpoint: `${supabaseUrl}/storage/v1/upload/resumable`,
        retryDelays: [0, 1000, 3000, 5000], // Retry delays in ms
        chunkSize: 6 * 1024 * 1024, // 6MB chunks
        headers: {
          authorization: `Bearer ${session.access_token}`,
          'x-upsert': 'false', // Don't overwrite existing files
        },
        uploadDataDuringCreation: true,
        removeFingerprintOnSuccess: true,
        metadata: {
          bucketName: STORAGE_BUCKET,
          objectName: fileName,
          contentType: file.type,
          cacheControl: '3600',
        },
        onError: (error) => {
          console.error('TUS upload error:', error);
          // Parse error message for user-friendly display
          let message = 'Failed to upload video.';
          if (error.message?.includes('exceeded')) {
            message = 'File size exceeds storage limit.';
          } else if (error.message?.includes('network')) {
            message = 'Network error. Please check your connection and try again.';
          } else if (error.message?.includes('unauthorized') || error.message?.includes('401')) {
            message = 'Session expired. Please log in again.';
          }
          reject(new Error(message));
        },
        onProgress: (bytesUploaded, bytesTotal) => {
          const percentage = Math.round((bytesUploaded / bytesTotal) * 100);
          onProgress?.(percentage);
        },
        onSuccess: () => {
          console.log('TUS upload completed:', fileName);
          onProgress?.(100);
          resolve(fileName);
        },
      });

      // Check for previous upload to resume
      const previousUploads = await upload.findPreviousUploads();
      if (previousUploads.length > 0) {
        console.log('Resuming previous upload...');
        upload.resumeFromPreviousUpload(previousUploads[0]);
      }

      // Start the upload
      upload.start();
    } catch (error) {
      console.error('TUS setup error:', error);
      reject(error);
    }
  });
}

/**
 * Get public URL for a video in storage
 */
export function getVideoUrl(path: string): string {
  const { data } = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(path);
  return data.publicUrl;
}

/**
 * Create a signed URL for private bucket access
 * Use this when the bucket is not public
 *
 * @param path - The storage path
 * @param expiresIn - Expiration time in seconds (default: 1 hour)
 */
export async function getSignedVideoUrl(path: string, expiresIn: number = 3600): Promise<string | null> {
  const { data, error } = await supabase.storage
    .from(STORAGE_BUCKET)
    .createSignedUrl(path, expiresIn);

  if (error) {
    console.error('Failed to create signed URL:', error);
    return null;
  }

  return data.signedUrl;
}

/**
 * Check if a video exists in storage
 */
export async function videoExists(path: string): Promise<boolean> {
  const { data, error } = await supabase.storage
    .from(STORAGE_BUCKET)
    .list(path.substring(0, path.lastIndexOf('/')), {
      search: path.substring(path.lastIndexOf('/') + 1),
    });

  if (error) {
    console.error('Error checking video existence:', error);
    return false;
  }

  return data && data.length > 0;
}

/**
 * Upload a thumbnail image to storage
 */
export async function uploadThumbnail(
  blob: Blob,
  sessionId: string,
  trackId: number
): Promise<string | null> {
  const fileName = `thumbnails/${sessionId}/${trackId}.jpg`;

  const { data, error } = await supabase.storage
    .from(STORAGE_BUCKET)
    .upload(fileName, blob, {
      contentType: 'image/jpeg',
      cacheControl: '3600',
      upsert: true,
    });

  if (error) {
    console.error('Thumbnail upload error:', error);
    return null;
  }

  const { data: urlData } = supabase.storage
    .from(STORAGE_BUCKET)
    .getPublicUrl(data.path);

  return urlData.publicUrl;
}

// ============================================
// Practice Recording Functions
// ============================================

/**
 * Upload a practice session recording to storage
 * Uses the practice-recordings bucket with user-scoped paths
 *
 * @param blob - The video blob from MediaRecorder
 * @param userId - The user ID for path organization
 * @param sessionId - The practice session ID
 * @param mimeType - The MIME type of the recording
 * @param onProgress - Optional progress callback
 * @returns Object with path and metadata, or null on failure
 */
export async function uploadPracticeRecording(
  blob: Blob,
  userId: string,
  sessionId: string,
  mimeType: string = 'video/webm',
  onProgress?: UploadProgressCallback
): Promise<{ path: string; size: number } | null> {
  // Validate size
  if (blob.size > MAX_FILE_SIZE) {
    console.error('Practice recording too large:', blob.size);
    throw new Error('Recording too large. Maximum size is 100MB.');
  }

  // Normalize MIME type - strip codec specification (e.g., "video/webm;codecs=vp9" -> "video/webm")
  // Supabase storage doesn't accept MIME types with codec parameters
  const baseMimeType = mimeType.split(';')[0].trim();

  // Determine file extension from MIME type
  const ext = baseMimeType.includes('mp4') ? 'mp4' : 'webm';
  const fileName = `${userId}/${sessionId}.${ext}`;

  try {
    // Report initial progress
    onProgress?.(5);

    // Get current session for auth
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) {
      throw new Error('Not authenticated');
    }

    // Use TUS for large files
    if (blob.size > RESUMABLE_THRESHOLD) {
      console.log(`Using TUS upload for practice recording (${(blob.size / 1024 / 1024).toFixed(2)}MB)`);
      const path = await uploadPracticeRecordingResumable(blob, fileName, baseMimeType, session.access_token, onProgress);
      return path ? { path, size: blob.size } : null;
    }

    // Standard upload for small files
    onProgress?.(10);
    const { data, error } = await supabase.storage
      .from(PRACTICE_RECORDINGS_BUCKET)
      .upload(fileName, blob, {
        contentType: baseMimeType,
        cacheControl: '3600',
        upsert: true,
      });

    if (error) {
      console.error('Practice recording upload error:', error);
      if (error.message?.includes('Bucket not found')) {
        throw new Error('Storage bucket not configured. Please run the Supabase migration.');
      }
      throw new Error(`Upload failed: ${error.message}`);
    }

    onProgress?.(100);
    return { path: data.path, size: blob.size };
  } catch (error) {
    console.error('Practice recording upload failed:', error);
    throw error;
  }
}

/**
 * TUS resumable upload for large practice recordings
 */
async function uploadPracticeRecordingResumable(
  blob: Blob,
  fileName: string,
  contentType: string,
  accessToken: string,
  onProgress?: UploadProgressCallback
): Promise<string | null> {
  return new Promise((resolve, reject) => {
    const upload = new tus.Upload(blob, {
      endpoint: `${supabaseUrl}/storage/v1/upload/resumable`,
      retryDelays: [0, 1000, 3000, 5000],
      chunkSize: 6 * 1024 * 1024,
      headers: {
        authorization: `Bearer ${accessToken}`,
        'x-upsert': 'true',
      },
      uploadDataDuringCreation: true,
      removeFingerprintOnSuccess: true,
      metadata: {
        bucketName: PRACTICE_RECORDINGS_BUCKET,
        objectName: fileName,
        contentType: contentType,
        cacheControl: '3600',
      },
      onError: (error) => {
        console.error('Practice recording TUS error:', error);
        reject(new Error('Upload failed. Please try again.'));
      },
      onProgress: (bytesUploaded, bytesTotal) => {
        const percentage = Math.round((bytesUploaded / bytesTotal) * 100);
        onProgress?.(percentage);
      },
      onSuccess: () => {
        console.log('Practice recording TUS upload completed:', fileName);
        onProgress?.(100);
        resolve(fileName);
      },
    });

    upload.start();
  });
}

/**
 * Get a signed URL for a practice recording
 * Practice recordings are private, so we need signed URLs
 *
 * @param path - The storage path
 * @param expiresIn - Expiration time in seconds (default: 1 hour)
 */
export async function getPracticeRecordingUrl(
  path: string,
  expiresIn: number = 3600
): Promise<string | null> {
  const { data, error } = await supabase.storage
    .from(PRACTICE_RECORDINGS_BUCKET)
    .createSignedUrl(path, expiresIn);

  if (error) {
    console.error('Failed to create signed URL for practice recording:', error);
    return null;
  }

  return data.signedUrl;
}

/**
 * Check if a practice recording exists
 */
export async function practiceRecordingExists(path: string): Promise<boolean> {
  const { data, error } = await supabase.storage
    .from(PRACTICE_RECORDINGS_BUCKET)
    .list(path.substring(0, path.lastIndexOf('/')), {
      search: path.substring(path.lastIndexOf('/') + 1),
    });

  if (error) {
    console.error('Error checking practice recording:', error);
    return false;
  }

  return data && data.length > 0;
}
