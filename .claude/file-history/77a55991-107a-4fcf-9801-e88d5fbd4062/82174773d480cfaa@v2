/**
 * Subject Lock Module
 *
 * Implements skeleton tracking persistence to prevent jumping between people.
 * Uses bounding box proximity matching to maintain consistent subject tracking
 * even when MediaPipe returns poses in different order between frames.
 */

import type { PoseLandmark } from './types';
import { POSE_LANDMARKS } from './pose-utils';

// Constants for tracking
const POSITION_MATCH_THRESHOLD = 0.15; // Max distance for position matching (normalized)
const SIZE_MATCH_THRESHOLD = 0.3; // Max size difference ratio
const MIN_CONFIDENCE_FOR_LOCK = 0.6; // Minimum average visibility to lock a subject
const FRAMES_TO_CONFIRM_LOCK = 3; // Frames needed to confirm initial lock

/**
 * Locked subject state
 */
export interface SubjectLock {
  isLocked: boolean;
  lockConfirmFrames: number;
  lastBbox: { x: number; y: number; w: number; h: number } | null;
  lastCenterOfMass: { x: number; y: number } | null;
  avgSize: number;
  trackHistory: { frame: number; poseIdx: number }[];
}

/**
 * Create initial subject lock state
 */
export function createSubjectLock(): SubjectLock {
  return {
    isLocked: false,
    lockConfirmFrames: 0,
    lastBbox: null,
    lastCenterOfMass: null,
    avgSize: 0,
    trackHistory: [],
  };
}

/**
 * Calculate bounding box from pose landmarks
 */
export function calculateBboxFromLandmarks(
  landmarks: PoseLandmark[]
): { x: number; y: number; w: number; h: number; centerX: number; centerY: number } {
  let minX = 1, minY = 1, maxX = 0, maxY = 0;
  let totalX = 0, totalY = 0, count = 0;

  // Use key body landmarks for stable bbox (shoulders, hips, knees)
  const keyIndices = [
    POSE_LANDMARKS.LEFT_SHOULDER,
    POSE_LANDMARKS.RIGHT_SHOULDER,
    POSE_LANDMARKS.LEFT_HIP,
    POSE_LANDMARKS.RIGHT_HIP,
    POSE_LANDMARKS.LEFT_KNEE,
    POSE_LANDMARKS.RIGHT_KNEE,
    POSE_LANDMARKS.LEFT_ANKLE,
    POSE_LANDMARKS.RIGHT_ANKLE,
  ];

  for (const idx of keyIndices) {
    const lm = landmarks[idx];
    if (lm && (lm.visibility ?? 0) > 0.3) {
      minX = Math.min(minX, lm.x);
      minY = Math.min(minY, lm.y);
      maxX = Math.max(maxX, lm.x);
      maxY = Math.max(maxY, lm.y);
      totalX += lm.x;
      totalY += lm.y;
      count++;
    }
  }

  if (count === 0) {
    return { x: 0.5, y: 0.5, w: 0, h: 0, centerX: 0.5, centerY: 0.5 };
  }

  return {
    x: minX,
    y: minY,
    w: maxX - minX,
    h: maxY - minY,
    centerX: totalX / count,
    centerY: totalY / count,
  };
}

/**
 * Calculate average visibility for key joints
 */
function calculateAverageVisibility(landmarks: PoseLandmark[]): number {
  const keyIndices = [
    POSE_LANDMARKS.LEFT_SHOULDER,
    POSE_LANDMARKS.RIGHT_SHOULDER,
    POSE_LANDMARKS.LEFT_HIP,
    POSE_LANDMARKS.RIGHT_HIP,
    POSE_LANDMARKS.LEFT_ELBOW,
    POSE_LANDMARKS.RIGHT_ELBOW,
  ];

  let total = 0;
  let count = 0;

  for (const idx of keyIndices) {
    const lm = landmarks[idx];
    if (lm) {
      total += lm.visibility ?? 0;
      count++;
    }
  }

  return count > 0 ? total / count : 0;
}

/**
 * Calculate distance between two bounding boxes
 */
function calculateBboxDistance(
  bbox1: { x: number; y: number; w: number; h: number; centerX: number; centerY: number },
  bbox2: { x: number; y: number; w: number; h: number; centerX: number; centerY: number }
): number {
  // Distance based on center of mass
  const dx = bbox1.centerX - bbox2.centerX;
  const dy = bbox1.centerY - bbox2.centerY;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Calculate size similarity between two bounding boxes
 */
function calculateSizeSimilarity(
  bbox1: { w: number; h: number },
  bbox2: { w: number; h: number }
): number {
  const size1 = bbox1.w * bbox1.h;
  const size2 = bbox2.w * bbox2.h;
  if (size1 === 0 || size2 === 0) return 0;
  return Math.min(size1, size2) / Math.max(size1, size2);
}

/**
 * Find the best matching pose from multiple detected poses
 * Returns the index of the pose that best matches the locked subject
 */
export function findLockedSubjectPose(
  allPoses: PoseLandmark[][],
  subjectLock: SubjectLock,
  frameIndex: number
): { poseIndex: number; updatedLock: SubjectLock } {
  if (allPoses.length === 0) {
    return { poseIndex: -1, updatedLock: subjectLock };
  }

  if (allPoses.length === 1) {
    // Only one pose - update lock based on this pose
    const bbox = calculateBboxFromLandmarks(allPoses[0]);
    const visibility = calculateAverageVisibility(allPoses[0]);

    return {
      poseIndex: 0,
      updatedLock: updateLockState(subjectLock, allPoses[0], 0, frameIndex, visibility),
    };
  }

  // Multiple poses detected - need to find the right one
  if (!subjectLock.isLocked || !subjectLock.lastBbox) {
    // Not locked yet - pick the pose with highest visibility/size (likely the main subject)
    let bestIdx = 0;
    let bestScore = -1;

    for (let i = 0; i < allPoses.length; i++) {
      const bbox = calculateBboxFromLandmarks(allPoses[i]);
      const visibility = calculateAverageVisibility(allPoses[i]);
      // Score: combination of size (closer = bigger) and visibility
      const sizeScore = bbox.w * bbox.h;
      const score = sizeScore * 0.4 + visibility * 0.6;

      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }

    const visibility = calculateAverageVisibility(allPoses[bestIdx]);
    return {
      poseIndex: bestIdx,
      updatedLock: updateLockState(subjectLock, allPoses[bestIdx], bestIdx, frameIndex, visibility),
    };
  }

  // Subject is locked - find the pose that best matches the locked position
  let bestIdx = 0;
  let bestMatchScore = -Infinity;

  for (let i = 0; i < allPoses.length; i++) {
    const bbox = calculateBboxFromLandmarks(allPoses[i]);
    const distance = calculateBboxDistance(bbox, { ...subjectLock.lastBbox!, centerX: subjectLock.lastCenterOfMass!.x, centerY: subjectLock.lastCenterOfMass!.y });
    const sizeSimilarity = calculateSizeSimilarity(bbox, subjectLock.lastBbox!);

    // Score: lower distance is better, higher size similarity is better
    // Normalize distance to 0-1 range (assuming max reasonable movement is 0.3)
    const normalizedDistance = Math.min(1, distance / 0.3);
    const matchScore = (1 - normalizedDistance) * 0.7 + sizeSimilarity * 0.3;

    if (matchScore > bestMatchScore) {
      bestMatchScore = matchScore;
      bestIdx = i;
    }
  }

  // Check if the best match is reasonable
  const bestBbox = calculateBboxFromLandmarks(allPoses[bestIdx]);
  const distance = calculateBboxDistance(bestBbox, { ...subjectLock.lastBbox!, centerX: subjectLock.lastCenterOfMass!.x, centerY: subjectLock.lastCenterOfMass!.y });

  if (distance > POSITION_MATCH_THRESHOLD * 2) {
    // Position jumped too far - might be tracking the wrong person
    // Keep using the lock but don't update position
    console.warn(`Subject tracking: Large position jump (${distance.toFixed(3)}), maintaining lock`);
    return {
      poseIndex: bestIdx,
      updatedLock: {
        ...subjectLock,
        trackHistory: [...subjectLock.trackHistory.slice(-10), { frame: frameIndex, poseIdx: bestIdx }],
      },
    };
  }

  const visibility = calculateAverageVisibility(allPoses[bestIdx]);
  return {
    poseIndex: bestIdx,
    updatedLock: updateLockState(subjectLock, allPoses[bestIdx], bestIdx, frameIndex, visibility),
  };
}

/**
 * Update lock state based on current pose
 */
function updateLockState(
  currentLock: SubjectLock,
  landmarks: PoseLandmark[],
  poseIndex: number,
  frameIndex: number,
  visibility: number
): SubjectLock {
  const bbox = calculateBboxFromLandmarks(landmarks);
  const newHistory = [...currentLock.trackHistory.slice(-10), { frame: frameIndex, poseIdx: poseIndex }];

  // Update lock confirmation
  let lockConfirmFrames = currentLock.lockConfirmFrames;
  let isLocked = currentLock.isLocked;

  if (!isLocked && visibility >= MIN_CONFIDENCE_FOR_LOCK) {
    lockConfirmFrames++;
    if (lockConfirmFrames >= FRAMES_TO_CONFIRM_LOCK) {
      isLocked = true;
      console.log(`Subject lock confirmed at frame ${frameIndex}`);
    }
  }

  // Calculate running average size
  const newSize = bbox.w * bbox.h;
  const avgSize = currentLock.avgSize === 0
    ? newSize
    : currentLock.avgSize * 0.8 + newSize * 0.2;

  return {
    isLocked,
    lockConfirmFrames,
    lastBbox: { x: bbox.x, y: bbox.y, w: bbox.w, h: bbox.h },
    lastCenterOfMass: { x: bbox.centerX, y: bbox.centerY },
    avgSize,
    trackHistory: newHistory,
  };
}

/**
 * Reset subject lock (when user wants to re-select)
 */
export function resetSubjectLock(): SubjectLock {
  return createSubjectLock();
}

/**
 * Check if lock is valid and stable
 */
export function isLockStable(lock: SubjectLock): boolean {
  return lock.isLocked && lock.trackHistory.length >= FRAMES_TO_CONFIRM_LOCK;
}
